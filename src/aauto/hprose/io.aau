// io  ‰»Î ‰≥ˆø‚
/**********************************************************\
|                                                          |
|                          hprose                          |
|                                                          |
| Official WebSite: http://www.hprose.com/                 |
|                   http://www.hprose.net/                 |
|                   http://www.hprose.org/                 |
|                                                          |
\**********************************************************/

/**********************************************************\
 *                                                        *
 * io.aau                                                 *
 *                                                        *
 * Hprose IO library for AAuto Quicker                    *
 *                                                        *
 * LastModified: Feb 9, 2013                              *
 * Author: Ma Bingyao <andot@hprose.com>                  *
 *                                                        *
\**********************************************************/

namespace hprose.io {
    var sub = ..string.sub;
    var join = ..string.join;
    var indexAny = ..string.indexAny;
    var pack = ..string.pack;
    var format = ..string.format;
    var push = ..table.push;
    var time = ..time;
    var count = ..table.count;
    var istime = ..time.istime;
    var NaN = -(0/0);
    var Inf = -(..math.log(0));

    ulen = function(str) {
        var len = #str;
        for (i = 1; #str; 1) {
            var c = str[i];
            select(c >>> 4) {
                case 0,1,2,3,4,5,6,7 {
                    // 0xxx xxxx
                }
                case 12,13 {
                    // 110x xxxx  10xx xxxx
                    if ((str[i + 1] >>> 6) != 2) return -1;
                    i += 1;
                    len -= 1;
                }
                case 14 {
                    // 1110 xxxx  10xx xxxx  10xx xxxx
                    if ((str[i + 1] >>> 6) != 2) return -1;
                    if ((str[i + 2] >>> 6) != 2) return -1;
                    i += 2;
                    len -= 2;
                }
                case 15 {
                    // 1111 0xxx  10xx xxxx  10xx xxxx  10xx xxxx
                    if ((c & 0xf) <= 4) {
                        i += 1;
                        var c2 = str[i];
                        if ((c2 >>> 6) != 2) return -1;
                        i += 1;
                        var c3 = str[i];
                        if ((c3 >>> 6) != 2) return -1;
                        i += 1;
                        var c4 = str[i];
                        if ((c4 >>> 6) != 2) return -1;
                        var s = ((c & 0x07) << 18) |
                               ((c2 & 0x3f) << 12) |
                               ((c3 & 0x3f) << 6)  |
                                (c4 & 0x3f) - 0x10000;
                        if ((0 <= s) && (s < 0xfffff)) {
                            len -= 2;
                            continue;
                        }
                    }
                    return -1;

                }
                else {
                    return -1;
                }
            }
        }
        return len;
    };

    var ulen = ..hprose.io.ulen;

    class InputStream {
        ctor(buf) {
            if (type(buf) !== type.string) error("buf must be a string.");
            var pos = 1;
            var length = #buf;
        };
        getc = function() {
            var c = buf[[pos]];
            pos += 1;
            return c;
        };
        read = function(len) {
            var b = sub(buf, pos, pos + len - 1);
            this.skip(len);
            return b;
        };
        readall = function() {
            return buf;
        };
        skip = function(n) {
            pos += n;
        };
        readuntil = function(tag) {
            var bp = pos;
            var c = buf[[pos]];
            pos += 1;
            while((c != tag) && (pos != length)) {
                c = buf[[pos]];
                pos += 1;
            }
            var ep = pos - 1;
            if (c == tag) ep -= 1;
            if (ep - bp < 0) return '';
            return sub(buf, bp, ep);
        };
        readUTF8String = function(len) {
            var p = pos;
            for (i = 1; len; 1) {
                var c = buf[pos];
                select(c >>> 4) {
                    case 0,1,2,3,4,5,6,7 {
                        // 0xxx xxxx
                        pos += 1;
                    }
                    case 12,13 {
                        // 110x xxxx  10xx xxxx
                        pos += 2;
                    }
                    case 14 {
                        // 1110 xxxx  10xx xxxx  10xx xxxx
                        pos += 3;
                    }
                    case 15 {
                        // 1111 0xxx  10xx xxxx  10xx xxxx  10xx xxxx
                        pos += 1;
                        if ((c & 0xf) <= 4) {
                            var c2 = buf[pos];
                            pos += 1;
                            var c3 = buf[pos];
                            pos += 1;
                            var c4 = buf[pos];
                            pos += 1;
                            var s = ((c & 0x07) << 18) |
                                   ((c2 & 0x3f) << 12) |
                                   ((c3 & 0x3f) << 6)  |
                                    (c4 & 0x3f) - 0x10000;
                            if ((0 <= s) && (s < 0xfffff)) {
                                i += 1;
                                continue;
                            }
                        }
                        error("bad utf-8 encoding");

                    }
                    else {
                        error("bad utf-8 encoding");
                    }
                }
            }
            return sub(buf, p, pos - 1);
        };
        @{
            _type = "hprose.io.InputStream";
        }
    }
    class OutputStream {
        ctor(str = '') {
            var buf = {str};
        };
        write = function(...) {
            push(buf, ...);
        };
        mark = function() {
            str = join(buf);
        };
        reset = function() {
            buf = {str};
        };
        clear = function() {
            buf = {};
        };
        @{
            _type = "hprose.io.OutputStream";
            _tostring = function() {
                return join(buf);
            };
        }
    }
    namespace HproseClassManager {
        var classCache = {};
        var aliasCache = {};
        register = function(cls, alias) {
            classCache[[alias]] = cls;
            aliasCache[[cls]] = alias;
        };
        getClassAlias = function(cls) {
            return aliasCache[[cls]];
        };
        getClass = function(alias) {
            return classCache[[alias]];
        };
    }
    namespace HproseTags {
        /* Serialize Tags */
        TagInteger = 'i';
        TagLong = 'l';
        TagDouble = 'd';
        TagNull = 'n';
        TagEmpty = 'e';
        TagTrue = 't';
        TagFalse = 'f';
        TagNaN = 'N';
        TagInfinity = 'I';
        TagDate = 'D';
        TagTime = 'T';
        TagUTC = 'Z';
        TagBytes = 'b';
        TagUTF8Char = 'u';
        TagString = 's';
        TagGuid = 'g';
        TagList = 'a';
        TagMap = 'm';
        TagClass = 'c';
        TagObject = 'o';
        TagRef = 'r';
        /* Serialize Marks */
        TagPos = '+';
        TagNeg = '-';
        TagSemicolon = ';';
        TagOpenbrace = '{';
        TagClosebrace = '}';
        TagQuote = '"';
        TagPoint = '.';
        /* Protocol Tags */
        TagFunctions = 'F';
        TagCall = 'C';
        TagResult = 'R';
        TagArgument = 'A';
        TagError = 'E';
        TagEnd = 'z';
    }
    var getClass = function(classname) {
        var cls = HproseClassManager.getClass(classname);
        if (cls) return cls;
        cls = class { @{ _type = classname } };
        HproseClassManager.register(cls, classname);
        return cls;
    };
    var readNumber = function(stream, tag){
        var s = stream.readuntil(tag);
        if (#s == 0) return 0;
        return (tonumber(s, 10));
    };
    class HproseRawReader {
        ctor(stream) {
            this.stream = stream;
            var tags = ..hprose.io.HproseTags;
        };
        unexpectedTag = function(tag, expectTags) {
            select(tag) {
                case null {
                    error('No byte found in stream');
                }
                else {
                    if (expectTags) {
                        error("tag '" ++ expectTags ++ "' expected, but '" ++ tag ++ "' found in stream");
                    }
                    else {
                        error("Unexpected serialize tag '" ++ tag ++ "' in stream");
                    }
                }
            }
        };
        readRaw = function(ostream, tag) {
            ostream := ..hprose.io.OutputStream();
            tag := stream.getc();
            ostream.write(tag);
            select(tag) {
                case '0';'9' {
                }
                case tags.TagNull,tags.TagEmpty,tags.TagTrue,tags.TagFalse,tags.TagNaN {
                }
                case tags.TagInfinity {
                    ostream.write(stream.getc());
                }
                case tags.TagInteger,tags.TagLong,tags.TagDouble,tags.TagRef {
                    this.readNumberRaw(ostream);
                }
                case tags.TagDate,tags.TagTime {
                    this.readDateTimeRaw(ostream);
                }
                case tags.TagUTF8Char {
                    this.readUTF8CharRaw(ostream);
                }
                case tags.TagBytes {
                    this.readBytesRaw(ostream);
                }
                case tags.TagString {
                    this.readStringRaw(ostream);
                }
                case tags.TagGuid {
                    this.readGuidRaw(ostream);
                }
                case tags.TagList,tags.TagMap,tags.TagObject {
                    this.readComplexRaw(ostream);
                }
                case tags.TagClass {
                    this.readComplexRaw(ostream);
                    this.readRaw(ostream);
                }
                case tags.TagError {
                    this.readRaw(ostream);
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
            return ostream;
        };
        readNumberRaw = function(ostream) {
            var tag;
            do {
                tag = stream.getc();
                ostream.write(tag);
            } while (tag != tags.TagSemicolon);
        };
        readDateTimeRaw = function(ostream) {
            var tag;
            do {
                tag = stream.getc();
                ostream.write(tag);
            } while ((tag != tags.TagSemicolon) && (tag != tags.TagUTC));
        };
        readUTF8CharRaw = function(ostream) {
            ostream.write(stream.readUTF8String(1));
        };
        readBytesRaw = function(ostream) {
            var count = 0;
            var tag = '0';
            do {
                count *= 10;
                count += tag[1] - 48;
                tag = stream.getc();
                ostream.write(tag);
            } while (tag != tags.TagQuote);
            ostream.write(stream.read(count + 1));
        };
        readStringRaw = function(ostream) {
            var count = 0;
            var tag = '0';
            do {
                count *= 10;
                count += tag[1] - 48;
                tag = stream.getc();
                ostream.write(tag);
            } while (tag != tags.TagQuote);
            ostream.write(stream.readUTF8String(count + 1));
        };
        readGuidRaw = function(ostream) {
            ostream.write(stream.read(38));
        };
        readComplexRaw = function(ostream) {
            var tag;
            do {
                tag = stream.getc();
                ostream.write(tag);
            } while (tag != tags.TagOpenbrace);
            while ((tag = stream.getc()) != tags.TagClosebrace) {
                this.readRaw(ostream, tag);
            }
            ostream.write(tag);
        };
    }
    class HproseSimpleReader {
        ctor(stream) {
            this = ..hprose.io.HproseRawReader(stream);
            var classref = {};
            var tags = ..hprose.io.HproseTags;
        };
        _checkTag = function(expectTag, tag) {
            if (tag != expectTag) this.unexpectedTag(tag, expectTag);
        };
        checkTag = function(expectTag) {
            this._checkTag(expectTag, stream.getc());
        };
        _checkTags = function(expectTags, tag) {
            if (!indexAny(expectTags, tag)) this.unexpectedTag(tag, expectTags);
            return tag;
        };
        checkTags = function(expectTags) {
            return this._checkTags(expectTags, stream.getc());
        };
        unserialize = function() {
            var tag = stream.getc();
            select(tag) {
                case '0';'9' {
                    return tag[1] - 48;
                }
                case tags.TagInteger {
                    return this.readIntegerWithoutTag();
                }
                case tags.TagLong {
                    return this.readLongWithoutTag();
                }
                case tags.TagDouble {
                    return this.readDoubleWithoutTag();
                }
                case tags.TagNull {
                    return null;
                }
                case tags.TagEmpty {
                    return '';
                }
                case tags.TagTrue {
                    return true;
                }
                case tags.TagFalse {
                    return false;
                }
                case tags.TagNaN {
                    return NaN;
                }
                case tags.TagInfinity {
                    return this.readInfinityWithoutTag();
                }
                case tags.TagDate {
                    return this.readDateWithoutTag();
                }
                case tags.TagTime {
                    return this.readTimeWithoutTag();
                }
                case tags.TagBytes {
                    return this.readBytesWithoutTag();
                }
                case tags.TagUTF8Char {
                    return this.readUTF8CharWithoutTag();
                }
                case tags.TagString {
                    return this.readStringWithoutTag();
                }
                case tags.TagGuid {
                    return this.readGuidWithoutTag();
                }
                case tags.TagList {
                    return this.readListWithoutTag();
                }
                case tags.TagMap {
                    return this.readMapWithoutTag();
                }
                case tags.TagClass {
                    this.readClass();
                    return this.readObject();
                }
                case tags.TagObject {
                    return this.readObjectWithoutTag();
                }
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagError {
                    error(this.readString());
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readIntegerWithoutTag = function() {
            return readNumber(stream, tags.TagSemicolon);
        };
        readInteger = function() {
            var tag = stream.getc();
            select(tag) {
                case '0';'9' {
                    return tag[1] - 48;
                }
                case tags.TagInteger {
                    return this.readIntegerWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readLongWithoutTag = function() {
            return stream.readuntil(tags.TagSemicolon);
        };
        readLong = function() {
            var tag = stream.getc();
            select(tag) {
                case '0';'9' {
                    return tag;
                }
                case tags.TagInteger, tags.TagLong {
                    return this.readLongWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readDoubleWithoutTag = function() {
            return readNumber(stream, tags.TagSemicolon);
        };
        readDouble = function() {
            var tag = stream.getc();
            select(tag) {
                case '0';'9' {
                    return tag[1] - 48;
                }
                case tags.TagInteger, tags.TagLong, tags.TagDouble {
                    return this.readDoubleWithoutTag();
                }
                case tags.TagNaN {
                    return NaN;
                }
                case tags.TagInfinity {
                    return this.readInfinityWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readNaN = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagNaN {
                    return NaN;
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readInfinityWithoutTag = function() {
            if (stream.getc() == tags.TagNeg) {
                return -Inf;
            }
            else {
                return Inf;
            }
        };
        readInfinity = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagInfinity {
                    return this.readInfinityWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readNull = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagNull {
                    return null;
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readEmpty = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagEmpty {
                    return '';
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readBoolean = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagTrue {
                    return true;
                }
                case tags.TagFalse {
                    return false;
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        _readDate = function() {
            var year = tonumber(stream.read(4), 10);
            var month = tonumber(stream.read(2), 10);
            var day = tonumber(stream.read(2), 10);
            var date;
            var tag = stream.getc();
            if (tag == tags.TagTime) {
                var hour = tonumber(stream.read(2), 10);
                var minute = tonumber(stream.read(2), 10);
                var second = tonumber(stream.read(2), 10);
                var millisecond = 0;
                tag = stream.getc();
                if (tag == tags.TagPoint) {
                    millisecond = tonumber(stream.read(3), 10);
                    tag = stream.getc();
                    if ((tag >= '0') && (tag <= '9')) {
                        stream.skip(2);
                        tag = stream.getc();
                        if ((tag >= '0') && (tag <= '9')) {
                            stream.skip(2);
                            tag = stream.getc();
                        }
                    }
                }
                if (tag == tags.TagUTC) {
                    date = time(null, "!%c");
                }
                else {
                    date = time();
                }
                date.hour = hour;
                date.minute = minute;
                date.second = second;
                date.milliseconds = millisecond;
            }
            else if (tag == tags.TagUTC) {
                date = time(null, "!%c");
            }
            else {
                date = time();
            }
            date.year = year;
            date.month = month;
            date.day = day;
            date.update();
            return date;
        };
        readDateWithoutTag = _readDate;
        readDate = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagDate {
                    return this.readDateWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        _readTime = function() {
            var hour = tonumber(stream.read(2), 10);
            var minute = tonumber(stream.read(2), 10);
            var second = tonumber(stream.read(2), 10);
            var millisecond = 0;
            var tag = stream.getc();
            if (tag == tags.TagPoint) {
                millisecond = tonumber(stream.read(3), 10);
                tag = stream.getc();
                if ((tag >= '0') && (tag <= '9')) {
                    stream.skip(2);
                    tag = stream.getc();
                    if ((tag >= '0') && (tag <= '9')) {
                        stream.skip(2);
                        tag = stream.getc();
                    }
                }
            }
            var date;
            if (tag == tags.TagUTC) {
                date = time(null, "!%c");
            }
            else {
                date = time();
            }
            date.year = 1970;
            date.month = 1;
            date.day = 1;
            date.hour = hour;
            date.minute = minute;
            date.second = second;
            date.milliseconds = millisecond;
            date.update();
            return date;
        };
        readTimeWithoutTag = _readTime;
        readTime = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagTime {
                    return this.readTimeWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        _readBytes = function() {
            var count = readNumber(stream, tags.TagQuote);
            var bytes = stream.read(count);
            stream.skip(1);
            return bytes;
        };
        readBytesWithoutTag = _readBytes;
        readBytes = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagBytes {
                    return this.readBytesWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readUTF8CharWithoutTag = function() {
            return stream.readUTF8String(1);
        };
        readUTF8Char = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagUTF8Char {
                    return this.readUTF8CharWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        _readString = function() {
            var count = readNumber(stream, tags.TagQuote);
            var s = stream.readUTF8String(count);
            stream.skip(1);
            return s;
        };
        readStringWithoutTag = _readString;
        readString = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagString {
                    return this.readStringWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        _readGuid = function() {
            stream.skip(1);
            var guid = stream.read(36);
            stream.skip(1);
            return guid;
        };
        readGuidWithoutTag = _readGuid;
        readGuid = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagGuid {
                    return this.readGuidWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        _readListBegin = function() {
        	return {};
        };
        _readListEnd = function(list) {
            var count = readNumber(stream, tags.TagOpenbrace);
            for (i = 1; count; 1) {
                list[[i]] = this.unserialize();
            }
            stream.skip(1);
            return list;
        };
        readListWithoutTag = function() {
            return this._readListEnd(this._readListBegin());
        };
        readList = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagList {
                    return this.readListWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        _readMapBegin = function() {
        	return {};
        };
        _readMapEnd = function(map) {
            var count = readNumber(stream, tags.TagOpenbrace);
            for (i = 1; count; 1) {
                var key = this.unserialize();
                var value = this.unserialize();
                map[[key]] = value;
            }
            stream.skip(1);
            return map;
        };
        readMapWithoutTag = function() {
            return this._readMapEnd(this._readMapBegin());
        };
        readMap = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagMap {
                    return this.readMapWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        _readObjectBegin = function() {
        	var clsinfo = classref[[readNumber(stream, tags.TagOpenbrace) + 1]];
            var obj = clsinfo[["cls"]]();
            return obj, clsinfo;
        }
        _readObjectEnd = function(obj, clsinfo) {
            for (i = 1; clsinfo[["count"]]; 1) {
                obj[[clsinfo[["fields"]][[i]]]] = this.unserialize();
            }
            stream.skip(1);
            return obj;
        }
        readObjectWithoutTag = function() {
            return this._readObjectEnd(this._readObjectBegin());
        };
        readObject = function() {
            var tag = stream.getc();
            select(tag) {
                case tags.TagRef {
                    return this.readRef();
                }
                case tags.TagClass {
                    this.readClass();
                    return this.readObject();
                }
                case tags.TagObject {
                    return this.readObjectWithoutTag();
                }
                else {
                    this.unexpectedTag(tag);
                }
            }
        };
        readClass = function() {
            var classname = this._readString();
            var count = readNumber(stream, tags.TagOpenbrace);
            var fields = {};
            for (i = 1; count; 1) {
                fields[[i]] = this.readString();
            }
            stream.skip(1);
            var clsinfo = {};
            clsinfo[["cls"]] = getClass(classname);
            clsinfo[["count"]] = count;
            clsinfo[["fields"]] = fields;
            classref[[#classref + 1]] = clsinfo;
        };
        readRef = function() {
            this.unexpectedTag(tags.TagRef);
        };
        _reset = function() {
            classref = {};
        }
        reset = _reset;
    }
    class HproseReader {
        ctor(stream) {
            this = ..hprose.io.HproseSimpleReader(stream);
            var ref = { @{ _weak = "v" } };
            var tags = ..hprose.io.HproseTags;
        };
        readDateWithoutTag = function() {
            var date = this._readDate();
            ref[[#ref + 1]] = date;
            return date;
        };
        readTimeWithoutTag = function() {
            var time = this._readTime();
            ref[[#ref + 1]] = time;
            return time;
        };
        readBytesWithoutTag = function() {
            var bytes = this._readBytes();
            ref[[#ref + 1]] = bytes;
            return bytes;
        };
        readStringWithoutTag = function() {
            var str = this._readString();
            ref[[#ref + 1]] = str;
            return str;
        };
        readGuidWithoutTag = function() {
            var guid = this._readGuid();
            ref[[#ref + 1]] = guid;
            return guid;
        };
        readListWithoutTag = function() {
            var list = this._readListBegin();
            ref[[#ref + 1]] = list;
            return this._readListEnd(list);
        };
        readMapWithoutTag = function() {
            var map = this._readMapBegin();
            ref[[#ref + 1]] = map;
            return this._readMapEnd(map);
        };
        readObjectWithoutTag = function() {
            var obj, clsinfo = this._readObjectBegin();
            ref[[#ref + 1]] = obj;
            return this._readObjectEnd(obj, clsinfo);
        };
        readRef = function() {
            return ref[[readNumber(stream, tags.TagSemicolon) + 1]];
        };
        reset = function() {
            this._reset();
            ref = { @{ _weak = "v" } };
        };
    }
    var isDigit = function(value) {
        select(value) {
            case 0;9 {
                return true;
            }
            case '0';'9' {
                return true;
            }
        }
        return false;
    };
    var isInteger = function(value) {
        for (i = (value[[1]] == '-' ? 2 : 1); #value; 1) {
            if (!isDigit(value[[i]])) return false;
        }
        return (value != '-');
    };
    var isInt32 = function(value) {
        var s = tostring(value);
        var l = #s;
        return ((l < 12) && isInteger(s) && !(value < -2147483648 || value > 2147483647));
    };
    var getClassName = function(obj) {
        var typename = obj@._type;
        var cls = eval(typename);
        var classname = HproseClassManager.getClassAlias(cls);
        if (classname) return classname;
        HproseClassManager.register(cls, typename);
        return typename;
    };
    var isPosInf = function(value) {
        return Inf == value;
    };
    var isNegInf = function(value) {
        return -Inf == value;
    };
    var isFinite = function(value) {
        return ((Inf > value) && (value > -Inf));
    };
    var isNaN = function(value) {
        return value !== value;
    };
    var isobject = function(value) {
        var cls, struct, typename = type(value);
        typename := struct;
        if (cls === "table") {
            var c;
            try {
                c = eval(typename);
            }
            catch(e){
                c = null;
            }
            if (type(c) === "class") return true;
        }
        return false;
    };
    var isarray = function(value) {
        return ((type(value) === type.table) && (count(value) === #value))
    };
    class HproseSimpleWriter {
        ctor(stream){
            this.stream = stream;
            var classref = {};
            var fieldsref = {};
            var tags = ..hprose.io.HproseTags;
        };
        serialize = function (variable) {
            select (type(variable)) {
                case type.null {
                    this.writeNull();
                }
                case type.boolean {
                    this.writeBoolean(variable);
                }
                case type.number {
                    if (isDigit(variable)) {
                        stream.write(pack(variable + 48));
                    }
                    elseif (isInt32(variable)) {
                        this.writeInteger(variable)
                    }
                    else {
                        this.writeDouble(variable);
                    }
                }
                case type.string {
                    var len = ulen(variable);
                    if (len < 0) {
                        this.writeBytesWithRef(variable);
                    }
                    elseif (len == 0) {
                        this.writeEmpty();
                    }
                    elseif (len == 1) {
                        this.writeUTF8Char(variable);
                    }
                    else {
                        this.writeStringWithRef(variable, len);
                    }
                }
                case type.table {
                    if (istime(variable)) {
                        this.writeDateTimeWithRef(variable);
                    }
                    elseif (isarray(variable)) {
                        this.writeListWithRef(variable);
                    }
                    elseif (isobject(variable)) {
                        this.writeObjectWithRef(variable);
                    }
                    else {
                        this.writeMapWithRef(variable);
                    }
                }
            }
        };
        writeInteger = function(i) {
            stream.write(tags.TagInteger, tostring(i), tags.TagSemicolon);
        };
        writeLong = function(l) {
            stream.write(tags.TagLong, tostring(l), tags.TagSemicolon);
        };
        writeDouble = function(d) {
            if (isNaN(d)) {
                this.writeNaN();
            }
            else if (isFinite(d)) {
                stream.write(tags.TagDouble, tostring(d), tags.TagSemicolon);
            }
            else {
                this.writeInfinity(d > 0);
            }
        };
        writeNaN = function() {
            stream.write(tags.TagNaN);
        };
        writeInfinity = function(positive) {
            stream.write(tags.TagInfinity, (positive ? tags.TagPos : tags.TagNeg));
        };
        writeNull = function() {
            stream.write(tags.TagNull);
        };
        writeEmpty = function() {
            stream.write(tags.TagEmpty);
        };
        writeBoolean = function(b) {
            stream.write(b ? tags.TagTrue : tags.TagFalse);
        };
        _writeDateTime = function(date) {
            var year = format("%04i",date.year);
            var month = format("%02i",date.month);
            var day = format("%02i",date.day);
            var hour = format("%02i",date.hour);
            var minute = format("%02i",date.minute);
            var second = format("%02i",date.second);
            var millisecond = format("%03i",date.milliseconds);
            var timezone = (date.format[[1]] == '!') ? tags.TagUTC : tags.TagSemicolon;

            if ((hour == '00') && (minute == '00') &&
                (second == '00') && (millisecond == '000')) {
                stream.write(tags.TagDate, year, month, day, timezone);
            }
            else if ((year == '1970') && (month == '01') && (day == '01')) {
                stream.write(tags.TagTime, hour, minute, second);
                if (millisecond != '000') {
                    stream.write(tags.TagPoint, millisecond);
                }
                stream.write(timezone);
            }
            else {
                stream.write(tags.TagDate, year, month, day,
                             tags.TagTime, hour, minute, second);
                if (millisecond != '000') {
                    stream.write(tags.TagPoint, millisecond);
                }
                stream.write(timezone);
            }
        }
        writeDateTime = function(date) {
            this._writeDateTime(date);
        };
        writeDateTimeWithRef = function(date) {
            if (!this.writeRef(date)) this.writeDateTime(date);
        };
        _writeBytes = function(bytes) {
            stream.write(tags.TagBytes, (#bytes : ''), tags.TagQuote, bytes, tags.TagQuote);
        };
        writeBytes = function(bytes) {
            this._writeBytes(bytes);
        }
        writeBytesWithRef = function(bytes) {
            if (!this.writeRef(bytes)) this.writeBytes(bytes);
        }
        writeUTF8Char = function(c) {
            stream.write(tags.TagUTF8Char, c);
        };
        _writeString = function(str, len) {
        	len := ulen(str);
            if (len < 0) error("must be encoding in utf8.");
            stream.write(tags.TagString, (len : ''), tags.TagQuote, str, tags.TagQuote);
        };
        writeString = function(str, len) {
            this._writeString(str, len);
        }
        writeStringWithRef = function(str, len) {
            if (!this.writeRef(str)) this.writeString(str, len);
        }
        _writeList = function(list) {
            var count = #list;
            stream.write(tags.TagList, (count : ''), tags.TagOpenbrace);
            for (i = 1; count; 1) {
                this.serialize(list[[i]]);
            }
            stream.write(tags.TagClosebrace);
        };
        writeList = function(list) {
            this._writeList(list);
        }
        writeListWithRef = function(list) {
            if (!this.writeRef(list)) this.writeList(list);
        }
        _writeMap = function(map) {
            var fields = {};
            for (key, value in map) {
                select(type(value)) {
                    case type.null, type.boolean, type.number, type.string, type.table {
                        fields[[#fields + 1]] = key;
                    }
                }
            }
            var count = #fields;
            stream.write(tags.TagMap, (count : ''), tags.TagOpenbrace);
            for (i = 1; count; 1) {
                this.serialize(fields[[i]]);
                this.serialize(map[[fields[[i]]]]);
            }
            stream.write(tags.TagClosebrace);
        };
        writeMap = function(map) {
            this._writeMap(map);
        }
        writeMapWithRef = function(map) {
            if (!this.writeRef(map)) this.writeMap(map);
        }
        _writeObjectBegin = function(obj) {
            var classname = getClassName(obj);
        	var fields;
        	var index = classref[[classname]];
            if (index === null) {
                fields = {};
                for (key, value in obj) {
                    select(type(value)) {
                        case type.null, type.boolean, type.number, type.string, type.table {
                            fields[[#fields + 1]] = tostring(key);
                        }
                    }
                }
                index = this.writeClass(classname, fields);
        	}
        	else {
        	    fields = fieldsref[[index]];
        	}
            stream.write(tags.TagObject, index - 1, tags.TagOpenbrace);
            return fields;
        }
        _writeObjectEnd = function(obj, fields) {
            var count = #fields;
            for (i = 1; count; 1) {
                this.serialize(obj[[fields[[i]]]]);
            }
            stream.write(tags.TagClosebrace);
        }
        writeObject = function(obj) {
            this._writeObjectEnd(obj, this._writeObjectBegin(obj));
        };
        writeObjectWithRef = function(obj) {
            if (!this.writeRef(obj)) this.writeObject(obj);
        };
        writeClass = function(classname, fields) {
            var count = #fields;
            var len = ulen(classname);
            if (len < 0) error("class name must be encoding in utf8.");
            stream.write(tags.TagClass, len, tags.TagQuote, classname, tags.TagQuote, (count : ''), tags.TagOpenbrace);
            for (i = 1; count; 1) {
                this.writeString(fields[i]);
            }
            stream.write(tags.TagClosebrace);
            var index = #fieldsref + 1;
            classref[classname] = index;
            fieldsref[index] = fields;
            return index;
        };
        writeRef = function(obj) {
            return false;
        }
        _reset = function() {
            classref = {};
            fieldsref = {};
        };
        reset = _reset;
    }
    class HproseWriter {
    	ctor(stream) {
    	    this = ..hprose.io.HproseSimpleWriter(stream);
    	    var ref = { @{ _weak = "k" } };
    	    var refcount = 0;
            var tags = ..hprose.io.HproseTags;
    	};
        writeDateTime = function(date) {
            ref[[date]] = refcount;
            refcount += 1;
            this._writeDateTime(date);
        };
        writeBytes = function(bytes) {
            ref[[bytes]] = refcount;
            refcount += 1;
            this._writeBytes(bytes);
        }
        writeString = function(str, len) {
            ref[[str]] = refcount;
            refcount += 1;
            this._writeString(str, len);
        }
        writeList = function(list) {
            ref[[list]] = refcount;
            refcount += 1;
            this._writeList(list);
        }
        writeMap = function(map) {
            ref[[map]] = refcount;
            refcount += 1;
            this._writeMap(map);
        }
        writeObject = function(obj) {
            var fields = this._writeObjectBegin(obj);
            ref[[obj]] = refcount;
            refcount += 1;
            this._writeObjectEnd(obj, fields);
        }
        writeRef = function(obj) {
            var index = ref[obj];
            if (index !== null) {
                stream.write(tags.TagRef, index, tags.TagSemicolon);
                return true;
            }
            return false;
        };
    	reset = function() {
    	    this._reset();
            ref = { @{ _weak = "k" } };
            refcount = 0;
    	}
    }

    namespace HproseFormatter {
        serialize = function(variable, simple = false) {
            var stream = ..hprose.io.OutputStream();
            var writer = (simple ? ..hprose.io.HproseSimpleWriter(stream) : ..hprose.io.HproseWriter(stream));
            writer.serialize(variable);
            return tostring(stream);
        }
        unserialize = function(variable_representation, simple = false) {
            var stream = ..hprose.io.InputStream(variable_representation);
            var reader = (simple ? ..hprose.io.HproseSimpleReader(stream) : ..hprose.io.HproseReader(stream));
            return reader.unserialize();
        }
    }
}